<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="o7yQBnLIoWby8Y5vNMQywBiMtev-ilWjXt89RQpTvVw">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://pinkyjie.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"utteranc","storage":true,"lazyload":false,"nav":null,"activeClass":"utteranc"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="如果前两年大家还在讨论grunt和gulp等构建工具的话，现在无疑是webapck的时代。严格来讲，webpack其实和grunt&#x2F;gulp根本不是一种东西，它不是一个构建工具，而是module bundler。简单来说，webpack将JS、CSS、HTML（包含各种预处理器）以及图片等等都视为“资源”，每个资源文件都是一个module文件，而module文件之间存在依赖，webpack就是根据">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack使用小记">
<meta property="og:url" content="http://pinkyjie.com/2016/03/05/webpack-tips/index.html">
<meta property="og:site_name" content="进击的马斯特">
<meta property="og:description" content="如果前两年大家还在讨论grunt和gulp等构建工具的话，现在无疑是webapck的时代。严格来讲，webpack其实和grunt&#x2F;gulp根本不是一种东西，它不是一个构建工具，而是module bundler。简单来说，webpack将JS、CSS、HTML（包含各种预处理器）以及图片等等都视为“资源”，每个资源文件都是一个module文件，而module文件之间存在依赖，webpack就是根据">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-03-05T15:29:17.000Z">
<meta property="article:modified_time" content="2020-05-01T01:47:54.594Z">
<meta property="article:author" content="马斯特">
<meta property="article:tag" content="AngularJS">
<meta property="article:tag" content="ui-router">
<meta property="article:tag" content="angular1-webpack-starter">
<meta property="article:tag" content="webpack">
<meta property="article:tag" content="LazyLoad">
<meta property="article:tag" content="ocLazyLoad">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://pinkyjie.com/2016/03/05/webpack-tips/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>webpack使用小记 | 进击的马斯特</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">进击的马斯特</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">CODING MY LIFE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://pinkyjie.com/2016/03/05/webpack-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/images/avatar.jpg">
      <meta itemprop="name" content="马斯特">
      <meta itemprop="description" content="前端 | 溜冰 | Mac">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进击的马斯特">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          webpack使用小记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-03-05 15:29:17" itemprop="dateCreated datePublished" datetime="2016-03-05T15:29:17+00:00">2016-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 01:47:54" itemprop="dateModified" datetime="2020-05-01T01:47:54+00:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具相关</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如果前两年大家还在讨论grunt和gulp等构建工具的话，现在无疑是<a href="https://webpack.github.io/" target="_blank" rel="noopener">webapck</a>的时代。严格来讲，webpack其实和grunt/gulp根本不是一种东西，它不是一个构建工具，而是<code>module bundler</code>。简单来说，webpack将JS、CSS、HTML（包含各种预处理器）以及图片等等都视为“资源”，每个资源文件都是一个module文件，而module文件之间存在依赖，webpack就是根据module文件间的依赖将所有module打包（bundle）起来。而回忆我们用grunt/gulp构建项目时，做的很大一部分工作也无非是将JS、CSS、HTML编译合并压缩等等，所以从这个层面上讲用webpack和grunt/gulp得到的结果是一样的。但webpack好就好在使用loader的概念让配置更加容易，再也不用和一堆文件路径打交道了。这篇文章就讲一下自己在使用webpack时的一些实践。</p>
<a id="more"></a>
<h3 id="使用npm管理所有依赖"><a href="#使用npm管理所有依赖" class="headerlink" title="使用npm管理所有依赖"></a>使用npm管理所有依赖</h3><p>说到前端的依赖管理，可能很多人脑海里第一印象还是<a href="http://bower.io/" target="_blank" rel="noopener">bower</a>，其实bower更像是一个依赖下载工具，你还是需要手动将这些下载好的文件用script标签引用到页面中去（尽管有<a href="https://github.com/tanodeptapship/wiredep" target="_blank" rel="noopener">wiredep</a>帮我们自动化），所以它其实并不能真正的做到“依赖管理”。另外，bower据说已经要停止开发了，与此同时，越来越多的前端项目都开始支持npm，支持使用node的CommonJS机制来发行它们的前端库。这样在前端项目的package.json中不仅需要<code>devDependencies</code>，长期受冷落的<code>dependencies</code>也要用起来了。前者用来声明一些build过程中需要用的到一些构建工具，而后者用来声明开发使用到的前端库。webpack虽然支持多种包管理机制，但CommonJS应该还是最推荐的吧。用npm将要使用的库安装好后，直接在js文件中require即可。当然，使用ES6的话（需配合Babel），import它也是支持的哦。这样一来，第三方库的管理，项目中文件间的依赖管理再也不是问题了，可以像写node以及其他后端语言那样畅快的引用来引用去了。</p>
<p>说到依赖管理，还有个问题不得不提。package.json文件中采用node的SemVer来管理版本号，默认的<code>^</code>符号会匹配最新的minor版本。简单的说，你安装的时候可能是<code>^1.4.3</code>，但是一旦1.5.0发布，你运行npm install就会装1.5.0，也就是说它只会保留第一个数字。所以有需要的话可以把<code>^</code>改为<code>~</code>，它的限制更严格一些，<code>~1.4.3</code>最多只会安装到1.4.9，可以最大程度的减少升级带来的兼容性问题。有人会想，有没有类似python的<code>pip freeze</code>功能把依赖锁死在指定的版本上呢？当然！试试<code>npm shrinkwrap</code>吧，它会将当前安装在node_modules下的依赖版本写死在生成的node-shrinkwrap.json文件中，将这个文件加到git里，别人使用npm install安装依赖包时就可以保证装到和你一模一样的版本了。</p>
<h3 id="善用yargs，避免多个配置文件"><a href="#善用yargs，避免多个配置文件" class="headerlink" title="善用yargs，避免多个配置文件"></a>善用yargs，避免多个配置文件</h3><p>很多github上的webpack starter项目都提供了多个webpack.config.js：如<code>webpack.prod.config.js</code>和<code>webpack.dev.config.js</code>，目的就是为了适配不同的环境。其实开发和发布的配置大部分是相同的，所以里面会有很多重复的配置。还有的项目看到了这一点，来了一个<code>webpack.make.config.js</code>提供默认的大部分配置，然后在其他的配置文件里require这个文件，做相应的更改。反正都是提供多个webpack配置文件，然后不同的环境用不同的。有必要这么复杂吗？在前面的文章中我反复提到一个概念，虽然<code>xxx.config.js</code>是配置文件，但是里面可以包含任何的node逻辑，所以为什么不试试只维护一个配置文件，针对不同的环境传不同的参数呢？像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --mock"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"rm -rf ./build &amp;&amp; webpack --progress --mock --prod"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认会查找名为<code>webpack.config.js</code>的配置文件，然后在这个文件中我们去处理自定义的参数即可。这里又要安利<a href="https://www.npmjs.com/package/yargs" target="_blank" rel="noopener">yargs</a>了，一个非常便捷的命令行参数处理工具。具体可以参考<a href="/2016/02/27/continuous-integration-with-travis-ci/#识别Travis的环境">前面文章</a>的讲解和它的文档，这里不再赘述。</p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>webpack的配置可以说就是<code>module</code>和<code>plugins</code>的配置，<code>module</code>里主要就是配置各种loaders，没啥可说的，你要require什么类型的文件就去搜相应的loader就好，这一节主要说后面的这个：<code>plugins</code>的配置。webpack支持非常多的插件，详见<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">插件列表</a>，下面就讲一些常用的场景会用到的插件。</p>
<h4 id="将jQuery全局暴露"><a href="#将jQuery全局暴露" class="headerlink" title="将jQuery全局暴露"></a>将jQuery全局暴露</h4><p>虽然很多人已经不提倡再使用jQuery，但很多第三方的库依然依赖jQuery，如果我们要使用这些第三方的库，那么我们还是没法摆脱jQuery。那么正常情况下我们只要保证jQuery的script标签在第三方库前面即可，因为jQuery中会暴露<script type="math/tex">`给全局（`window.</script>）使用。但使用了webpack后情况就稍显复杂了，作为module bundler，默认是不会有任何module暴露给全局的。这样，如果第三方库的代码中出现<script type="math/tex">.xxx`或`jQuery.xxx`或`window.jQuery`或`window.</script>则会直接报错。要达到类似的效果，则需要使用webpack内置的ProvidePlugin插件，配置很简单，只需要：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">"jquery"</span>,</span><br><span class="line">    jQuery: <span class="string">"jquery"</span>,</span><br><span class="line">    <span class="string">"window.jQuery"</span>: <span class="string">"jquery"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样，当webpack碰到require的第三方库中出现全局的<code>$</code>、<code>jQeury</code>和<code>window.jQuery</code>时，就会使用node_module下jquery包export出来的东西了。</p>
<h4 id="给JS定义全局flag"><a href="#给JS定义全局flag" class="headerlink" title="给JS定义全局flag"></a>给JS定义全局flag</h4><p>在JS代码中我们常常需要一些静态的flag来标识是开发环境还是生产环境，一个简单的例子就是，开发环境你的log可能是直接console里打出来就好，而生产环境中就需要将log上传到统一的地方方便查询。也就是说，有些代码可能只是为了生产环境而存在的，而有些代码只为开发环境存在。我在为生产环境编译打包的时候就需要移除这些没用的代码，移除的操作<a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">UglifyJS</a>可以胜任，但前提是它只移除类似<code>if (false) {...}</code>的代码片段，所以我们要做的就是定义全局的布尔flag，在build的时候传入不同的参数来控制它是true还是false。这时就需要使用webpack内置的DefinePlugin插件了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// args = require('yargs').argv;</span></span><br><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    __PROD__: args.prod，</span><br><span class="line">    __MOCK__: args.mock</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>上面我们同样使用了yargs，这样在build时传入<code>--prod</code>，则变量<code>__PROD__</code>即为true，传入<code>--mock</code>则<code>__MOCK__</code>为true。在JS代码中就可以使用类似的判断<code>if (__PROD__) {...}</code>了。</p>
<h4 id="第三方库输出单独的JS"><a href="#第三方库输出单独的JS" class="headerlink" title="第三方库输出单独的JS"></a>第三方库输出单独的JS</h4><p>一般我们为生产环境打包JS时，不管源文件有多少个，一般都是输出两个最终文件：<code>app.js</code>和<code>vendor.js</code>（LazyLoad的情况另说），前者是我们自己编写的代码合并压缩而成，后者是我们使用的第三方库合并压缩后的结果。使用webpack实现这个需要也很简单，使用webpack内置的CommonsChunkPlugin即可，我们要做的就是两步：</p>
<ul>
<li>在entry中定义app和vendor这两个模块：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: [</span><br><span class="line">        <span class="string">'source/app/index.js'</span></span><br><span class="line">    ],</span><br><span class="line">    vendor: [</span><br><span class="line">        <span class="string">'angular'</span>,</span><br><span class="line">        <span class="string">'angular-ui-router'</span>,</span><br><span class="line">        <span class="string">'angular-animate'</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在plugins里使用该插件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'vendor'</span>, isProd ? <span class="string">'vendor.[hash].js'</span> : <span class="string">'vendor.js'</span>)</span><br></pre></td></tr></table></figure>
<p>这样，所有模块中只要有require到vendor数组中定义的这些第三方模块，那么这些第三方模块都会被统一提取出来，放入<code>vendor.js</code>中去。在插件的配置中我们还进行了判断，如果是生产环境则给最终生成的文件名加hash。</p>
<h4 id="将CSS由style内嵌变成独立-css文件"><a href="#将CSS由style内嵌变成独立-css文件" class="headerlink" title="将CSS由style内嵌变成独立.css文件"></a>将CSS由style内嵌变成独立.css文件</h4><p>在处理CSS时webpack需要两个不同的loader：<code>css-loader</code>和<code>style-loader</code>，前者负责将CSS文件变成文本返回，并处理其中的url()和@import()，而后者将CSS以style标签的形式插入到页面中去。一般使用的时候这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">    loader: <span class="string">'style!css?sourceMap!autoprefixer!stylus'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的loader配置中，我们处理所有的styl文件（stylus），先用stylus-loader将stylus变成CSS，然后使用autoprefixer-loader添加各种浏览器兼容性前缀，最后使用css-loader和style-loader。但这样的问题就是所有CSS文件都是直接以style标签的形式插入页面，不利于缓存，我们还是更习惯build之后能够输出单独的.css文件。这时就需要webpack的<a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a>插件了，注意它不是内置的，需要额外安装。它的使用也很简单，分两步：</p>
<ul>
<li>在loaders定义中指定：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">    loader: ExtractTextPlugin.extract(<span class="string">'style'</span>, <span class="string">'css?sourceMap!autoprefixer!stylus'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在plugins中使用插件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">new</span> ExtractTextPlugin(isProd ? <span class="string">'[name].[hash].css'</span> : <span class="string">'[name].css'</span>)</span><br></pre></td></tr></table></figure>
<p>同样，这里我们在生产环境使用了hash命名。</p>
<h4 id="copy指定文件到指定路径"><a href="#copy指定文件到指定路径" class="headerlink" title="copy指定文件到指定路径"></a>copy指定文件到指定路径</h4><p>按理说用了webpack后所有的模块都通过require来管理了，用不着这样针对某个文件的copy了。这确实是一个不太常见的场景，比如说使用ES6的项目中，即便使用了Babel，但它并不会翻译类似<code>Symbol</code>这样的关键字，造成IE的兼容性问题：IE里会直接报“Symbol not defined”错误。这个时候我们就需要在页面中引入Babel里自带的shim文件了，<code>babel-core</code>中有一个browser-polyfill.min.js文件，是浏览器直接可以include的文件，并不需要使用webpack把它包一层。所以我们要做的其实是build的时候将这个文件copy到指定的目录，然后在index.html中包含这个文件即可。这个时候就需要<a href="https://www.npmjs.com/package/copy-webpack-plugin" target="_blank" rel="noopener">copy-webpack-plugin</a>这个插件了，配置起来也是非常的简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="string">'node_modules/babel-core/browser-polyfill.min.js'</span>, <span class="attr">to</span>: <span class="string">'polyfill.js'</span>&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>这样文件就会被复制到webpack的output.path配置的路径下了。</p>
<h4 id="定义入口HTML文件"><a href="#定义入口HTML文件" class="headerlink" title="定义入口HTML文件"></a>定义入口HTML文件</h4><p>单页应用还是需要一个入口的index.html文件的，这个文件的功能就是include所有的JS、CSS文件，然后body里指定一个ng-view或ui-view即可。这么机械化有规律的动作当然有插件来帮我们做了，那就是<a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a>。最简单的配置就是直接在plugins直接定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin()</span><br></pre></td></tr></table></figure>
<p>默认的配置会生成一个结构非常简单的index.html文件，HTML的title是“Webpack App”，然后entry中定义的bundle生成的JS会以script标签包在body里，CSS会以link标签包在head里。显然，默认的模板是没法满足我们的需求的，我们需要给插件传入参数进行配置：</p>
<ul>
<li>title和filename：控制生成页面的title和文件名。</li>
<li>inject：控制JS插入的位置，body或者head。</li>
<li>favicon：可以指定一个favicon.ico文件路径，作为网站的图标。</li>
<li>chunks和excludeChunks：一个数组，包含你需要引入或排除的bundle的名字（定义在entry中）。</li>
<li>template：自定义模板。</li>
</ul>
<p>这里我们重点来说一说template这个配置，因为Angular的场景是在body里需要一个ui-view的，所以我们必须要自定义模板。template不仅支持直接传入HTML文件的路径，也支持各种模板语言，来看看这个定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'jade!./source/app/index.jade'</span>,</span><br><span class="line">    chunks: [<span class="string">'app'</span>, <span class="string">'vendor'</span>],</span><br><span class="line">    favicon: <span class="string">'favicon.ico'</span>,</span><br><span class="line">    appName: appName</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>在template中我们指定了jade模板文件，然后配上jade-loader。这里注意的是，如果你想向jade文件中传参数，类似<code>jade?foo=bar!xxx.jade</code>，貌似是不支持的。那怎么实现这个需求呢？比如我想让build的时候动态决定index.html中的ng-app名字，怎么办呢？上面的<code>appName: appName</code>就是答案。在传给插件的配置中，除了它自身支持的配置，我们可以传入任意名称的键值对，然后在jade文件中可以这样访问到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html(lang&#x3D;&quot;en&quot;, ng-app&#x3D; htmlWebpackPlugin.options.appName)</span><br></pre></td></tr></table></figure>
<p>除了<code>htmlWebpackPlugin</code>变量外，在自定义模板中，还可以访问<code>webpack</code>和<code>webpackConfig</code>，前者可以获取webpack的stats，如<code>webpack.hash</code>获取本次webpack编译得到的hash码，后者可以获取webpack的所有配置。这两个变量在一些场景下也是非常有用的。最后还是一点要说，html-webpack-plugin支持生成多个HTML文件，只要在plugins中定义多个<code>new htmlWebpackPlugin({...})</code>即可。</p>
<h4 id="p参数的坑"><a href="#p参数的坑" class="headerlink" title="-p参数的坑"></a><code>-p</code>参数的坑</h4><p><code>-p</code>参数是官方推荐的Production shortcut，意思就是为生产环境build时请使用<code>webpack -p</code>，那么<code>-p</code>指什么？文档里说了，代表<code>--optimize-minimize</code>和<code>--optimize-occurence-order</code>这两个命令行参数。先来说说第二个，在<a href="http://webpack.github.io/docs/list-of-plugins.html#occurrenceorderplugin" target="_blank" rel="noopener">文档</a>里解释了，webpack会把所有的chunk当做资源进行编号，这个插件可以保证出现次数多的资源编号小一些，短一点，这样有助于减小最终的文件大小。再来看看第一个<code>--optimize-minimize</code>，在webpack的<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">插件列表文档</a>中没有找到。没关系，我们直接搜源码，可以发现，在<code>webpack/bin/convert-argv.js</code>（1.12.14版本）中有这么一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(<span class="string">"optimize-minimize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">    <span class="keyword">var</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">"../lib/optimize/UglifyJsPlugin"</span>);</span><br><span class="line">    options.plugins.push(<span class="keyword">new</span> UglifyJsPlugin());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也就是说，这个参数实际上会加载UglifyJsPlugin这个插件，而且是无参（默认参数）加载的。这里坑就来了！如果你的ES6代码中出现类似这样的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MockData <span class="keyword">from</span> <span class="string">'./e2e.data'</span>;</span><br><span class="line">angular.module(<span class="string">'appTest'</span>, [])</span><br><span class="line">    .service(MockData.name, MockData)</span><br><span class="line"></span><br><span class="line"><span class="comment">// e2e.data.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockData</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MockData;</span><br></pre></td></tr></table></figure>
<p>也就是说，使用module的<code>.name</code>属性来决定一个service的名字，然后在别的地方使用依赖注入来引入这个service的话，这个时候一旦你使用<code>-p</code>参数，程序就会报错：找不到provider，<code>MockDataProvider &lt;- MockData</code>。因为在e2e.data.js文件中你export的class虽然叫MockData，但这个名字会被UglifyJsPlugin改掉。这是因为这个插件有一个<code>mangle</code>选项，会对所有函数名变量名进行混淆，在压缩的同时保证安全。这倒没什么，坑就坑在，webpack自己的文档中告诉大家这个mangle的option默认是flase的，也就是说不会混淆。但在UglifyJsPlugin插件的源码里明明写着<code>if(options.mangle !== false) {...}</code>，除非你传入一个flase，默认确实是会混淆的。你说这误导不误导，我在Github上提了个issue：<a href="https://github.com/webpack/docs/issues/49" target="_blank" rel="noopener">webpack/docs #49</a>，虽然官方没管，但最新的文档中貌似已经修复了这个错误。所以我的建议是：<strong>不要使用<code>-p</code>参数</strong>！想要什么自己定义就好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isProd) &#123;</span><br><span class="line">    plugins.push(</span><br><span class="line">        <span class="keyword">new</span> webpack.NoErrorsPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.DedupePlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">                warnings: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mangle: <span class="literal">false</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面的定义，在build的时候只要使用<code>webpack --prod</code>就好。还有一点值得一说，如果你使用了<code>-p</code>，即便你额外定义了一个自己的mangle=false的UglifyJsPlugin插件在webpack配置里，也是不起作用的。所以，还是那句话，不要使用<code>-p</code>参数。</p>
<h3 id="轻松实现LazyLoad"><a href="#轻松实现LazyLoad" class="headerlink" title="轻松实现LazyLoad"></a>轻松实现LazyLoad</h3><p>使用webpack的<a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener">Code Splitting</a>可以非常方便的实现LazyLoad。对于大型的应用来说，一次性将所有文件全部下载进浏览器显得很不划算，因为有些功能可能不太常用，不需要一开始就加载。Code Splitting功能可以在代码中定义“分割点”，即代码执行到这些点时才会去加载所需的模块，这样就实现了按需加载的LazyLoad。下面就以Angular和ui-router为例来看看具体怎么LazyLoad。假设我们的网站有4个大页面（每个页面里可能有很多子页面），我们希望路由到某个页面时再去加载这个页面所需要的模块。要实现这个LazyLoad，我们要明确两点：</p>
<ol>
<li>“分割点”设在哪？</li>
<li>一个页面需要的模块包括HTML、CSS、JS，具体怎么去加载这三种类型？</li>
</ol>
<p>第一个问题很简单，由于我们的想法是在路由到某个页面时再去加载所需模块，所以很自然的，我们会想把“分割点”放在路由的定义中。放在路由中还可以帮我们解决第二个问题，因为路由中通常需要定义路由到这个页面时的template和controller，这恰恰是我们上面提到的HTML和JS部分。下面我们就来看看具体怎么操作吧。</p>
<h4 id="通过templateProvider动态加载模板"><a href="#通过templateProvider动态加载模板" class="headerlink" title="通过templateProvider动态加载模板"></a>通过templateProvider动态加载模板</h4><p>我们可以在定义路由的时候在template中去动态加载所需的模板，但是template参数是个string，显然不满足我们的要求（templateUrl显然也不适合我们的场景）。这里就需要ui-router的<a href="http://angular-ui.github.io/ui-router/site/#/api/ui.router.state.$stateProvider#methods_state" target="_blank" rel="noopener">templateProvider参数</a>了，它的值可以是一个函数，然后在这个函数中支持返回一个promise，由这个promise最终来返回HTML字符串。来看看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$stateProvider.state(<span class="string">'root.layout.phone'</span>, &#123;</span><br><span class="line">    views: &#123;</span><br><span class="line">        url: <span class="string">'/phone'</span>,</span><br><span class="line">        <span class="string">'main@root'</span>: &#123;</span><br><span class="line">            templateProvider: [<span class="string">'$q'</span>, ($q) =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> $q(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">require</span>.ensure([], () =&gt; &#123;</span><br><span class="line">                        resolve(<span class="built_in">require</span>(<span class="string">'./phone.jade'</span>));</span><br><span class="line">                    &#125;, <span class="string">'phone'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;],</span><br><span class="line">            controller: <span class="string">'PhoneController as vm'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们想要在访问<code>/phone</code>这个路由时再去加载<code>phone.jade</code>这个template。来看看templateProvider的配置，首先它的函数返回一个promise（第6行），这个promise我们直接使用<code>$q</code>的构造函数，这个构造函数接受两个参数：<code>resolve</code>和<code>reject</code>，分别用来resolve和reject这个promise。然后在这个promise中我们要resolve的就是<code>phone.jade</code>这个template的字符串内容，使用jade-loader配置后，<code>require(&#39;./phone.jade&#39;)</code>返回的就是jade编译后的HTML字符串了（第8行）。那么什么时候去resolve呢？这里我们重点来看看第7行：webpack的<code>require.ensure</code>函数，我们就是使用这个函数来实现“Code Splitting”的，它有三个参数：</p>
<ol>
<li>依赖的模块数组：模块名组成的数组，webpack会先加载这些模块再执行后面的回调函数。</li>
<li>回调函数：在模块数组加载完以后才会执行这个。</li>
<li>chunk的名字：从这个“分割点”分割出去的模块会放入额外的模块，这个参数指定模块的名字。这个参数主要用于存在多个<code>require.ensure</code>的情况，我们可以将多个“分割点”分割出去的代码放入同一个模块。</li>
</ol>
<p>为什么我们在第7行使用一个空数组呢？其实我们可以写<code>require.ensure([&#39;./phone.jade&#39;], () =&gt; {resolve(require(&#39;./phone.jade&#39;));}, &#39;phone&#39;)</code>，但因为我们在回调里立马又require了这个jade，所以外面不写是无所谓的。</p>
<h4 id="使用resolve来动态加载所需JS"><a href="#使用resolve来动态加载所需JS" class="headerlink" title="使用resolve来动态加载所需JS"></a>使用resolve来动态加载所需JS</h4><p>说完了templateProvider，我们再来看看下面的controller参数，controller参数与平常的写法并没有什么区别（第12行），因为没有一个叫controllerProvider的参数来让我们做类似的事情。那controller的JS模块在哪里动态加载呢？别忘了我们有resolve啊，每个路由定义都可以有一个resolve，只有这个resolve的promise被resolve了（有点绕了。。。）才会真正进入到那个路由中去，所以这正是我们加载controller和phone模块依赖的其它模块的好时机。来看看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    loadModule: [<span class="string">'$q'</span>, <span class="string">'$ocLazyLoad'</span>, ($q, $ocLazyLoad) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> $q(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">require</span>.ensure([], () =&gt; &#123;</span><br><span class="line">                $ocLazyLoad.load(&#123;<span class="attr">name</span>: <span class="built_in">require</span>(<span class="string">'./index'</span>).name&#125;);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;, <span class="string">'phone'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为这个resolve取名loadModule，因为它的作用就是加载phone模块自身的所有JS文件以及它所依赖的其它模块，并不需要我们真正的去return什么，所以第6行我们直接resolve了空值。另外注意第7行我们同样使用了phone作为chunk名，这保证了这个“分割点”分割出去的代码和上面分割出去的template是在一起的。那么JS依赖具体是怎么加载进来的呢？全靠第5行的<code>./index.js</code>文件了，来看看看这个<code>./index.js</code>的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angular <span class="keyword">from</span> <span class="string">'angular'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PhoneController <span class="keyword">from</span> <span class="string">'./phone.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> PhoneAddController <span class="keyword">from</span> <span class="string">'./add/phone-add.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> PhoneDetailController <span class="keyword">from</span> <span class="string">'./detail/phone-detail.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> PhoneService <span class="keyword">from</span> <span class="string">'./phone.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> phoneForm <span class="keyword">from</span> <span class="string">'../../components/phone-form'</span>;</span><br><span class="line"><span class="keyword">import</span> phoneTable <span class="keyword">from</span> <span class="string">'../../components/phone-table'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.module(<span class="string">'app.pages.phone'</span>, [</span><br><span class="line">    phoneForm.name,</span><br><span class="line">    phoneTable.name</span><br><span class="line">])</span><br><span class="line">    .controller(PhoneController.name, PhoneController)</span><br><span class="line">    .controller(PhoneAddController.name, PhoneAddController)</span><br><span class="line">    .controller(PhoneDetailController.name, PhoneDetailController)</span><br><span class="line">    .service(<span class="string">'PhoneAPI'</span>, PhoneService);</span><br></pre></td></tr></table></figure>
<p>可以看到，这个文件除了将phone模块自身的一些controller/service引入进来，还引入了它所依赖的component模块：phoneForm和phoneTable，所以只要require了它就可以保证phone的所有依赖都引进来了。最后，你肯定奇怪第5行的写法了，这里为什么需要<code>$ocLazyLoad</code>呢？<a href="https://github.com/ocombe/ocLazyLoad" target="_blank" rel="noopener">ocLazyLoad</a>是一个适用于Angular的Lazyload的库，其实我们只用它就可以实现Angular的LazyLoad，但这里我们用它的作用并不是动态加载文件，而是<strong>使webpack动态加载进来的文件中的Angular的module名<code>app.pages.phone</code>生效</strong>。因为Angular是不允许动态去声明一个module的，我们需要使用这种方法来使动态加载进来的文件中包含的Angular的module生效。</p>
<p>讲完了HTML和JS，那CSS怎么办呢？其实有了css-loader我们完全可以把它放在JS中或HTML中通过<code>require(xxx.css)</code>加载进来，因为通常CSS是与某个页面或某个模块绑定的（公用的样式除外），所以放在某个HTML中或某个JS模块中来require它也是合情合理的。</p>
<p>这样一来，phoen模块依赖的所有HTML、JS、CSS都动态加载进来了，在真正build的时候，会生成一个名为<code>phone.js</code>的文件（可以使用webpack的output.chunkFilename来配置生成的chunk文件的名称规则）来包含这些东西，而这个文件只有你第一次访问<code>/phone</code>的时候才会动态加载进来，这一点可以访问<a href="http://pinkyjie.com/angular1-webpack-starter/#/">http://pinkyjie.com/angular1-webpack-starter/#/</a> 并打开console来验证。</p>
<h4 id="style-loader的坑"><a href="#style-loader的坑" class="headerlink" title="style-loader的坑"></a>style-loader的坑</h4><p>这样设置了以后，所有动态加载的HTML、CSS和JS都会放在最终生成的<code>phone.js</code>中，也就是说，webpack目前是不支持为chunk生成单独<br>的CSS文件的，我提了个issue：<a href="https://github.com/webpack/webpack/issues/1758" target="_blank" rel="noopener">webpack/webpack #1758</a>，但目前还没回应。这会产生什么问题呢？如果你要动态加载的CSS中含有图片路径，比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span> url(<span class="string">"../../components/_layout/logo.png"</span>) top center no-repeat</span><br></pre></td></tr></table></figure>
<p>那么最终得到的CSS中路径虽然是正确的：<code>url(/assets/images/logo.46e065707257b2930a699c7cdacd7e86.png) top center no-repeat</code>（具体路径与你的file-loader配置有关），但Chrome会将这个路径解析为：<code>chrome-devtools://devtools/bundled/assets/images/logo.46e065707257b2930a699c7cdacd7e86.png</code>，因为CSS文件是以动态bundle的形式加载进来的，所以图片资源的相对路径是以bundle为准的，这将导致图片无法正常的显示。已经有人在style-loader的项目里提了bug：<a href="https://github.com/webpack/style-loader/issues/93" target="_blank" rel="noopener">webpack/style-loader #93</a>，但目前style-loader还没有修复。好消息是Vue的作者fork了一份style-loader并<a href="https://github.com/vuejs/vue-style-loader/commit/70b9f6ac2a2c1f2525c7e8945173d34957510ef6" target="_blank" rel="noopener">修复了这个问题</a>，所以暂时大家可以使用<a href="https://github.com/vuejs/vue-style-loader" target="_blank" rel="noopener">vue-style-loader</a>代替style-loader来解决这个问题。</p>
<p>最后，完整的实现可以看我Github上的<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="noopener">angular1-webpack-starter</a>项目。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/AngularJS/" rel="tag"># AngularJS</a>
              <a href="/tags/ui-router/" rel="tag"># ui-router</a>
              <a href="/tags/angular1-webpack-starter/" rel="tag"># angular1-webpack-starter</a>
              <a href="/tags/webpack/" rel="tag"># webpack</a>
              <a href="/tags/LazyLoad/" rel="tag"># LazyLoad</a>
              <a href="/tags/ocLazyLoad/" rel="tag"># ocLazyLoad</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/02/27/continuous-integration-with-travis-ci/" rel="prev" title="用 TravisCI 来做持续集成">
      <i class="fa fa-chevron-left"></i> 用 TravisCI 来做持续集成
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/02/21/recent-overseas-interview-experiences/" rel="next" title="最近的海外面试（前端）经历">
      最近的海外面试（前端）经历 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="PinkyJie/pinkyjie.github.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用npm管理所有依赖"><span class="nav-number">1.</span> <span class="nav-text">使用npm管理所有依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#善用yargs，避免多个配置文件"><span class="nav-number">2.</span> <span class="nav-text">善用yargs，避免多个配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用插件"><span class="nav-number">3.</span> <span class="nav-text">常用插件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将jQuery全局暴露"><span class="nav-number">3.1.</span> <span class="nav-text">将jQuery全局暴露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给JS定义全局flag"><span class="nav-number">3.2.</span> <span class="nav-text">给JS定义全局flag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三方库输出单独的JS"><span class="nav-number">3.3.</span> <span class="nav-text">第三方库输出单独的JS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将CSS由style内嵌变成独立-css文件"><span class="nav-number">3.4.</span> <span class="nav-text">将CSS由style内嵌变成独立.css文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy指定文件到指定路径"><span class="nav-number">3.5.</span> <span class="nav-text">copy指定文件到指定路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义入口HTML文件"><span class="nav-number">3.6.</span> <span class="nav-text">定义入口HTML文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#p参数的坑"><span class="nav-number">3.7.</span> <span class="nav-text">-p参数的坑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻松实现LazyLoad"><span class="nav-number">4.</span> <span class="nav-text">轻松实现LazyLoad</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过templateProvider动态加载模板"><span class="nav-number">4.1.</span> <span class="nav-text">通过templateProvider动态加载模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用resolve来动态加载所需JS"><span class="nav-number">4.2.</span> <span class="nav-text">使用resolve来动态加载所需JS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#style-loader的坑"><span class="nav-number">4.3.</span> <span class="nav-text">style-loader的坑</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马斯特"
      src="/assets/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">马斯特</p>
  <div class="site-description" itemprop="description">前端 | 溜冰 | Mac</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">186</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PinkyJie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PinkyJie" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pinkyjie.gn@gmail.com" title="E-Mail → mailto:pinkyjie.gn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/PinkyJie" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;PinkyJie" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://stackoverflow.com/users/689948/pinkyjie" title="StackOverflow → http:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;689948&#x2F;pinkyjie" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马斯特</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1253033676&web_id=1253033676"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  <script>
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','8k3UxSuRWYkrhVg55bC3','2.0.0');
</script>













  

  

  

</body>
</html>
